<!DOCTYPE html>
<html>
<head>
    <title>Star Wars Navigation Chart</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Mapbox GL JS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.js"></script>

    <!-- Turf.js -->
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>

    <!-- Mapbox Directions Plugin -->
    <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.0.0/mapbox-gl-directions.css" rel="stylesheet" />
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.0.0/mapbox-gl-directions.js"></script>

    <!-- Custom styles -->
    <link href="https://fonts.googleapis.com/css2?family=Urbanist:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <link rel="stylesheet" href="./style.css" type="text/css">
</head>
<body>
    <div id="map" style="width: 100%; height: 100vh;"></div>
    <div class="search-container">
        <input type="text" id="search-input" placeholder="Search a system">
        <button id="search-button">Search</button>
    </div>
    <div class="toggle-background-container">
        <button id="toggle-background"><i class="fas fa-star"></i></button>
    </div>
    <div class="toggle-routing-container">
        <button id="toggle-routing"><i class="fas fa-route"></i></button>
    </div>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoibmVzcCIsImEiOiJjbHg1dDE5Mm4xY2h5Mmlxc2R2Mm95Y3ByIn0.Kp1Lcr9XD_u6oy8QOpvOZQ';

        // Load the external layers list
        fetch('./layers/layers.json')
            .then(response => response.json())
            .then(layers => initializeMap(layers))
            .catch(error => console.error('Error loading layers:', error));

        function initializeMap(layers) {
            var map = new mapboxgl.Map({
                container: 'map',
                style: {
                    version: 8,
                    sources: layers.sources,
                    layers: layers.layers
                },
                center: [0.00847486, -0.0109944],
                zoom: 18
            });

            var allFeatures = [];

            // Load all features from the systems.geojson
            fetch('./layers/systems.geojson')
                .then(response => response.json())
                .then(data => {
                    allFeatures = data.features;
                });

            // Toggle background functionality
            var currentBackground = 'space-background';

            document.getElementById('toggle-background').addEventListener('click', function() {
                var newBackground = currentBackground === 'space-background' ? 'white-background' : 'space-background';
                map.setLayoutProperty(currentBackground, 'visibility', 'none');
                map.setLayoutProperty(newBackground, 'visibility', 'visible');
                currentBackground = newBackground;
            });

            // Search functionality
            document.getElementById('search-button').addEventListener('click', function() {
                const searchInput = document.getElementById('search-input').value.trim();
                if (!searchInput) {
                    alert('Please enter a system name');
                    return;
                }

                const searchWords = searchInput.toLowerCase().split(' ');

                let foundFeature = null;

                for (const feature of allFeatures) {
                    const featureName = feature.properties.NAME;
                    if (!featureName) continue;
                    const nameWords = featureName.toLowerCase().split(' ');

                    const allWordsMatch = searchWords.every(searchWord =>
                        nameWords.some(nameWord => nameWord.includes(searchWord))
                    );

                    if (allWordsMatch) {
                        foundFeature = feature;
                        break;
                    }
                }

                if (foundFeature) {
                    const coordinates = foundFeature.geometry.coordinates;
                    map.flyTo({ center: coordinates, zoom: 20 });
                } else {
                    alert('System not found');
                    map.setZoom(18); // Reset zoom if not found
                }
            });

            var startPoint, endPoint;
            var routingActive = false;

            document.getElementById('toggle-routing').addEventListener('click', function() {
                routingActive = !routingActive;
                this.style.backgroundColor = routingActive ? '#79aaca' : 'rgba(0, 0, 0, 0.8)';
                if (routingActive) {
                    map.once('click', function(event) {
                        startPoint = [event.lngLat.lng, event.lngLat.lat];
                        console.log('Start node:', startPoint);

                        map.once('click', function(event) {
                            endPoint = [event.lngLat.lng, event.lngLat.lat];
                            console.log('End node:', endPoint);
                            calculateAndDisplayRoute();
                        });
                    });
                }
            });

            function calculateAndDisplayRoute() {
                if (!startPoint || !endPoint) {
                    alert('Please select both start and end points.');
                    return;
                }

                // Use Turf.js to process the route data
                fetch('./layers/routes.geojson')
                    .then(response => response.json())
                    .then(routeData => {
                        // Find the nearest points on the routes to startPoint and endPoint
                        var nearestStart = turf.nearestPointOnLine(routeData, turf.point(startPoint));
                        var nearestEnd = turf.nearestPointOnLine(routeData, turf.point(endPoint));

                        // Find the actual route between nearestStart and nearestEnd points
                        var path = findRoute(routeData, nearestStart, nearestEnd);

                        if (path) {
                            var route = {
                                type: 'FeatureCollection',
                                features: [{
                                    type: 'Feature',
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: path
                                    }
                                }]
                            };

                            // Update the route-line source with the new route data
                            map.getSource('route-line').setData(route);
                        } else {
                            console.error('No path found between the selected points.');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading or processing route data:', error);
                    });
            }

            function findRoute(routeData, nearestStart, nearestEnd) {
                // Graph data structure for Dijkstra's algorithm
                var graph = {};
                routeData.features.forEach((feature, index) => {
                    var coordinates = feature.geometry.coordinates;
                    coordinates.forEach((coord, i) => {
                        var key = coord.join(',');
                        if (!graph[key]) {
                            graph[key] = {};
                        }
                        if (i > 0) {
                            var prevKey = coordinates[i - 1].join(',');
                            graph[key][prevKey] = turf.distance(turf.point(coord), turf.point(coordinates[i - 1]));
                            graph[prevKey][key] = graph[key][prevKey];
                        }
                    });
                });

                // Dijkstra's algorithm implementation
                function dijkstra(graph, start, end) {
                    var distances = {};
                    var parents = {};
                    var visited = new Set();

                    for (var node in graph) {
                        distances[node] = Infinity;
                        parents[node] = null;
                    }
                    distances[start] = 0;

                    while (Object.keys(visited).length !== Object.keys(graph).length) {
                        var closestNode = null;
                        for (var node in distances) {
                            if (!visited.has(node)) {
                                if (closestNode === null || distances[node] < distances[closestNode]) {
                                    closestNode = node;
                                }
                            }
                        }
                        if (closestNode === null) break;
                        visited.add(closestNode);

                        for (var neighbor in graph[closestNode]) {
                            var newDist = distances[closestNode] + graph[closestNode][neighbor];
                            if (newDist < distances[neighbor]) {
                                distances[neighbor] = newDist;
                                parents[neighbor] = closestNode;
                            }
                        }
                    }

                    var path = [];
                    var currentNode = end;
                    while (currentNode !== null) {
                        path.push(currentNode.split(',').map(Number));
                        currentNode = parents[currentNode];
                    }
                    path.reverse();
                    return path;
                }

                var startKey = nearestStart.geometry.coordinates.join(',');
                var endKey = nearestEnd.geometry.coordinates.join(',');
                return dijkstra(graph, startKey, endKey);
            }
        }
    </script>
</body>
</html>
